알고리즘 패러다임: 자주 나타나는 알고리즘 접근법

1.  Brute Force (무차별 대입 공격)
- 가능한 모든 경우의 수 시도하기  (ex: 조합)
- 일반적으로 비효율적, 시간복잡도 높음 / 직관적이고 명확함, 코드 구현 쉬움, 답을 확실하게 찾음
- 효율적인 알고리즘의 첫 시작



2.  Divide and Conquer (분할 정복)
- 문제를 여러 개의 부분 문제로 분할한 뒤 각 부분 문제들의 솔루션을 합쳐서 기존 문제 해결
- 1.  Divide 2. Conquer(부분문제 재귀적으로 접근해야 하기도 함) 3. Combine
*
 합병정렬 (divide and conquer 사용)
1. 리스트를 반으로 나눈다. 2. 왼쪽 리스트와 오른쪽 리스트를 각각 정렬한다. 3. 정렬된 두 리스트를 하나의 정렬된 리스트로 합병한다
(각 리스트의 0번부터 비교, 인덱스 맨 앞 비교하여 더 작은 것을 정렬된 리스트 안으로(기존 리스트에서 삭제), 하나의 리스트 다 끝나면 나머지 리스트 그대로 넣어줌.)
(len1 되면 베이스케이스로 conqour, 부분문제 합쳐가면서 기존 문제로 올라오기, combine 중심 알고리즘)
*
퀵정렬 (quicksort)
- 퀵정렬에서 리스트를 나누는 과정 = 파티션
    (1). 피봇(기준점, 편의상 가장 오른쪽) 정하기 (2). 피봇을 기준으로 더 작은 값은 왼쪽, 큰 값은 오른쪽으로 오게 함.
1. devide: 파티션을 하는 과정 2. pivot 왼쪽과 오른쪽 수 각각 정렬(전체리스트 정렬됨)  3. conquer
    * 재귀적으로 진행: 파티셔닝 재귀 반복 (base case: 부분문제의 피봇을 기준으로 양쪽에 값이 없거나 하나만 있을 때)
partition 함수
def partition(my_list, start, end)
# index start부터 end까지 파티셔닝    #파티셔닝 범위를 다시 그룹 4개로 분리(pivot, small, big, unknown)
    p = end   #pivot
    big 그룹이 시작되는 인덱스 = b
    unknown이 시작되는 인덱스 = i
    - 시작할 때: 범위의 모든 요소들이 unknown, i랑 b는 가장 왼쪽 인덱스를 가리키게 세팅
    - i와 p 비교(big or small?), big일 때는 i 한 칸 오른쪽으로, small일때는 b와 i 위치 바꾼 뒤 둘 다 오른쪽으로 한 칸)
    - 이와 같은 과정 반복하면 범위의 요소들이 small-big-pivot 그룹 순으로 정렬됨. 마지막 i=p되면 b와 p 위치 바꿈
    - 피봇 왼쪽에는 small 그룹, 오른쪽에는 big group인 형태로 정렬됨.