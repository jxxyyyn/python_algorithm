좋은 알고리즘이란?
1. 문제를 해결하는 것  2. 문제를 더 잘 해결하는 것


탐색 = 저장된 정보들 중에서 원하는 값을 찾는 것 (ex: 리스트에서 특정 수 찾기)
* 선형 탐색 알고리즘(linear search algorithm)
순서대로 탐색하여 원하는 값 찾기
* 이진 탐색 알고리즘(binary search algorithm)
전체 리스트의 중간값을 기준으로 찾고 있는 값이 중간값의 왼쪽, 오른쪽에 있는지 판별. 동일한 행동을 반복함

비교하기: len(list) = 16일 때 이진탐색 시 가장 금방되는 경우 1번, 가장 오래걸리는 경우 4번
                            선형탐색 시                1번,                   16번
                    선형탐색의 경우 이진탐색에 비해 리스트의 길이에 비례해서 빠른 속도로 커짐
그럼에도 선형탐색을 쓰는 경우: 리스트가 정렬되어있지 않을 때 (이진탐색은 정렬된 리스트에만 가능)



정렬 = 원소들을 특정 순서로 정리하는 것 (ex: sorted(_), .sort()
* 선택 정렬(Selection sort)
각 위치에 어떤 값이 들어갈지 찾는다.
방법: [0:]부터 [1:], [2:], [3:] ... 순서대로 최솟값 찾아 0, 1, 2, 3, ...에 넣기
* 삽입 정렬(insertion sort)
각 값이 어떤 위치에 들어갈지 찾는다.
방법: 각 숫자마다 리스트[0~n]에서 들어갈 위치 찾기(비교할 때는 정렬된 숫자 중 큰것들 부터 역순으로) (기존의 자료(들)은 필요에 따라 오른쪽으로 한 칸씩)

비교하기: 거의 정렬된 리스트를 정렬할 때는 삽입 정렬이 가장 빠름, 무작위 순서의 리스트를 정렬할 때는 힙 정렬
         역순으로 정렬된 리스트는 삽입 정렬 매우 오래 걸림.
         선택정렬과 합병 정렬은 상황에 영향을 받지 않고 일정한 시간 소요



알고리즘 평가의 기준: 시간(처리 시간)** / 공간(소요 메모리 양)
시간 복잡도(Time Complexity): 데이터가 많아질 수록 소요 시간이 얼마나 급격히 증가하는지를 나타내는 지표
    - 거듭제곱(exponentiation)
    - 로그(logarithms): 거듭제곱의 반대 개념, log aB = x 일 때 a^x = B
      b를 a로 몇번 나누어야 1이 되는가? (ex: 리스트 길이 16일 때 4회 2등분하면 1 나옴(위치 특정))
    - 1부터 n까지의 합 = n(1+n)/2
점근 표기법(Big-O Notation)
    - 소요시간: 점근표기법 20n + 40 : O(n) Big O of n
                        2n^2+8n+157 : O(n^2)
                        5n^3+100n^2 + 75 : O(n^3)
                        20logn+60 : O(logn)
    - 가정: n이 매우 크다(시간복잡도는 절대적인 시간이 아닌 성능성을 중시하기 때문)

